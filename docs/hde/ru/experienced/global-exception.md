# Углублённое изучение GlobalException

(исходник: [src/GlobalException.php](../../../../src/GlobalException.php))

Иногда вам требуется больше гибкости при работе с [GlobalException](../dummies/global-exception.md). Данная статья
описывает некоторые нестандартные ситуации и возможные способы их разрешения. Если вы ещё не знакомы с основным
функционалом библиотеки, [изучите его](../dummies/about.md) в первую очередь!

Содержание:
- [Неподходящий максимум базового кода](#неподходящий-максимум-базового-кода)
- [Ограничение глобального кода для приложения](#ограничение-глобального-кода-для-приложения)
- [Глобальные исключения из другого мира](#глобальные-исключения-из-другого-мира)
- [Форматирование глобальных кодов](#форматирование-глобальных-кодов)

## Неподходящий максимум базового кода

Допустим, ваше приложение начало использовать внешний сервис; давайте назовём его _ExtApp_. Этот сервис может
выбрасывать исключения. Вы создаёте очередного наследника [GlobalException](../dummies/global-exception.md), нарекаете
его `ExtAppException` и задаёте ему уникальный _код класса_; пусть это будет **29**. Итак, когда _ExtApp_ бросает
исключение **5101**, вы передаёте его код в конструктор `ExtAppException` в качестве _базового кода_, получаете ваш
_глобальный код_ **2905101**, и все счастливы...

ВНЕЗАПНО _ExtApp_ выбрасывает исключение с кодом **325009**. Затем происходят плохие вещи:
- `validateCodeBase()` считает данный код некорректным (ибо этот код **не** меньше числа **100000**).
- Исключение не считается _глобальным_, `getCode()` возвращает **325009** как есть.
- _Код класса_ исключения считается равным **0**, если значение, полученное при вызове `getCode()`, разбирается с
помощью `getCodeParts()` (применение данного метода упоминается
[ниже в этой статье](#глобальные-исключения-из-другого-мира)).
- [Parser](../dummies/parser.md#валидация-исключений) бросает ошибку валидации, если вы добавите исключение в
`ExtAppException::EXCEPTIONS_PROPERTIES[325009]`.

### Решение

Увеличьте максимум _базового кода_ для `ExtAppException`.

[GlobalException](../dummies/global-exception.md#валидация-кодов) предоставляет константу `CLASS_CODE_MULTIPLIER`,
которая используется в любых валидациях или вычислениях, имеющих отношение к _базовому_ или _глобальному_ кодам.
Изначально значение этой константы равно **100000** - всякий _базовый код_ должен быть меньше этого значения, чтобы
считаться корректным.

Вы можете переопределить эту константу для класса `ExtAppException`. Сначала представьте возможный максимальный код
исключения, которое может быть выброшено _ExtApp_; предположим, что он будет где-то около **99999999** (**8**
разрядов). Ваш следующий шаг - переопределить `ExtAppException::CLASS_CODE_MULTIPLIER`, задав значение, равное десяти
в степени **8**:

```php
class ExtAppException extends GlobalException
{
    const CLASS_CODE_MULTIPLIER = 10 ** 8;
    // ...
}
```

Готово! Вам даже не нужно менять _код класса_ для `ExtAppException`! С этого момента, если _ExtApp_ выбросит исключение
с кодом **325009**, ваш класс `ExtAppException` успешно вычислит для него _глобальный код_ **2900325009**

Вам также стоит принять во внимание, что теперь, если вы зададите тот же самый _код класса_ **29** для другого класса
исключений, такой _код класса_ может считаться дубликатом только в том случае, если тот новый класс также будет
содержать переопределённую константу `CLASS_CODE_MULTIPLIER` с тем же значением, что и в `ExtAppException`. В ином
случае отсутствие дубликатов _глобальных кодов_ в пределах этих двух классов гарантировано (и
[Parser](../dummies/parser.md#валидация-классов) может это доказать):

```php
class ExtAppException extends MyAppBaseException
{
    const CLASS_CODE_MULTIPLIER = 10 ** 8;
}

class AnotherException extends MyAppBaseException
{
}

class MyAppBaseException extends GlobalException
{
    const CLASS_CODE_LIST = [
        ExtAppException::class  => 29, // CLASS_CODE_MULTIPLIER = 10 ** 8;
        AnotherException::class => 29, // CLASS_CODE_MULTIPLIER = 10 ** 5;
    ];
}

echo ExtAppException::getCodeGlobal(1) . "\n";  // >> 2900000001
echo AnotherException::getCodeGlobal(1) . "\n"; // >> 2900001
```

В то же время и по той же причине вы **не** должны задавать классу `AnotherException` _код класса_ **29000**. Иначе
возможно вычисление дубликата _глобального кода_ (что подтвердит [Parser](../dummies/parser.md), бросив в этом случае
ошибку валидации).

## Ограничение глобального кода для приложения

Корректность _глобального кода_ исключения ограничена условиями корректности _базового кода_ и _кода класса_. Вы уже
должны знать [настоящее условие для _базового кода_](#неподходящий-максимум-базового-кода) и способ его изменить.

_Код класса_ проверяется с помощью `validateCodeClass()` - по условиям он должен быть положительным (или равным **0**
в случае отключения механизма глобализации), но меньше значения, которое возвращает `getCodeClassMax()`. Это условие
гарантирует, что возможный максимум _глобального кода_ не превысит максимальное целое в самом PHP. Однако иногда вам
может потребоваться значительно уменьшить этот максимум.

К примеру, если API вашего прилолжения использует [протокол XML-RPC](http://xmlrpc.scripting.com/spec.html),
возможности вашего API ограничены: _faultCode_ (а также все прочие целочисленные значения) должен быть в пределах
32-битного целого со знаком - протокол не поддерживает _int8_. Так что вам нужно гарантировать, что ваши _глобальные
коды_ не превысят 32-битное целое со знаком.

### Решение

`getCodeClassMax()` финализирован умышленно. Вместо этого измените константу `GLOBAL_CODE_MAX_RELATIVE`. Изначально её
значение равняется `PHP_INT_MAX`, но вы можете уменьшить его до ограничения вашего приложения. Для примера,
приведённого выше, вам следует задать ограничение на основе максимума 32-битного целого со знаком:

```php
// Все ваши классы исключений, участвующие в API вашего приолжения, должны наследовать данный класс:
class MyAppOrAPIBaseException extends GlobalException
{
    // ...
    const GLOBAL_CODE_MAX_RELATIVE = 2 ** 31 - 1; // 2147483647
    // ...
}
```

Теперь, если вы не будете менять `CLASS_CODE_MULTIPLIER`, ваш максимальный _код класса_ будет равен **21473**. Если вы
выбросите исключение такого класса с _базовым кодом_ **99999**, вы получите _глобальный код_ **2147399999**, который
определённо меньше максимума 32-битного целого со знаком (**2147483647**).

## Глобальные исключения из другого мира

Это здорово, когда только ваше приложение использует [GlobalException](../dummies/global-exception.md)! Но когда API
приложения вашего партнёра тоже начинает использовать этот функционал, в какой-то момент (в зависимости от ваших
значений `CLASS_CODE_MULTIPLIER` и `GLOBAL_CODE_MAX_RELATIVE`) вы не сможете рассматривать коды исключений этого
внешнего API в качестве _базовых кодов_. Вам придётся рассматривать их в качестве _глобальных кодов_ и соответствующим
образом создавать ваши объекты [GlobalException](../dummies/global-exception.md) (особенно если вы также используете
функционал [CustomizableException](../dummies/customizable-exception.md)).

### Решение

Давайте представим сценарий, в котором вы можете быть уверены, какие именно _коды классов_ использует внешнее
приложение для вычисления его _глобальных кодов_. К примеру, его API может вернуть коды в диапазоне от **1100001** до
**1599999** (_коды классов_ находятся в диапазоне от **11** до **15**, используется одно и тот же значение
`CLASS_CODE_MULTIPLIER`, равное **100000**).

1. Создайте пять новых классов исключений (для каждого возможного _кода класса_); обновите ваш `CLASS_CODE_LIST`,
добавив соответствующие пять _кодов классов_.
1. Генерируйте перевёрнутую версию `CLASS_CODE_LIST`, чтобы определять имя класса по _коду класса_.
1. Разбирайте _глобальные коды_, приходящие из внешнего API, с помощью `getCodeParts()` - этот метод возвращает массив
с разделёнными _кодом класса_ и _базовым кодом_.
1. Создайте ваше глобальное исключение - определите класс по извлечённому _коду класса_ и вызовите его конструктор,
сообщив последнему извлечённый _базовый код_.

### Худший сценарий

Просто представьте себе, если два или более внешних API начнут использовать
[GlobalException](../dummies/global-exception.md) и станут возвращать одинаковые _глобальные коды_ с разными смыслами.
И вам не удастся убедить разработчиков тех внешних приложений изменить _коды классов_. Также вы не сможете
рассматривать такие коды в качестве _базовых_ из-за размеров этих целых чисел.

На текущий момент [GlobalException](../dummies/global-exception.md) не в состоянии предложить вам решение данной
проблемы... Вам придётся рассматривать такие исключения как не глобальные и отличать их между собой и остальными
исключениями каким-то другим способом.

Не стесняйтесь создавать топики или pull request-ы, предлагая вашу удачную стратегию или улушение библиотеки для
такого сценария!

## Форматирование глобальных кодов

Если вы хотите вывести отформатированный _глобальный код_, переопределите и используйте статический метод
`getCodeFormatted()`. Изначально этот метод просто возвращает _глобальный код_ как есть и принимает _базовый код_ в
качестве единственного аргумента.

`getCodeFormatted()` вызывается в методах `CustomizableException::getMessageFeStub()` и
`CustomizableException::getMessageDefault()`. Читайте _Углублённое изучение CustomizableException_ для получения
подробностей о
[заглушке для пользовательского сообщения](customizable-exception.md#заглушка-для-пользовательского-сообщения) и
[базовом сообщении по умолчанию](customizable-exception.md#базовое-сообщение-по-умолчанию).

## Читайте также

- [Углублённое изучение CustomizableException](customizable-exception.md)
- [Углублённое изучение Parser](parser.md)
- [Основы GlobalException](../dummies/global-exception.md)
